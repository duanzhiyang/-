MyBatis:持久层框架，支持定制化SQL，存储过程，以及高级映射。Mybatis避免了几乎所有JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或
		注解来配置和映射原生信息，将接口和Java的POJOs映射成数据库中的记录。
		
		
	入门：
		从XML中构建sqlSessionFactory:
			每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而
				SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。
			从XML文件中构建SqlSessionFactory的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流（InputStream）实例，
				包括字符串形式的文件路径或者 file://的URL形式的文件路径来配置，MyBatis包含一个名叫Resources的工具类，它包含一些实用方法，可使
				从classpath或其他位置加载资源文件更加容易。
				eg：String resource = "";
					InputStream input = Resources.getResourceAsStream(resource);
					SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(input);
			XML配置文件中包含了对mybatis系统的核心设置，包含了获取数据库连接实例的数据源（DataSource）和决定事物作用域和控制事物管理器。
				environment元素提中包含了事物管理和连接池的配置。mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射
				定义信息)。
				eg：
					<?xml version="1.0" encoding="UTF-8" ?>
						<!DOCTYPE configuration
						  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
						  "http://mybatis.org/dtd/mybatis-3-config.dtd">
						<configuration>
						  <environments default="development">
							<environment id="development">
							  <transactionManager type="JDBC"/>
							  <dataSource type="POOLED">
								<property name="driver" value="${driver}"/>
								<property name="url" value="${url}"/>
								<property name="username" value="${username}"/>
								<property name="password" value="${password}"/>
							  </dataSource>
							</environment>
						  </environments>
						  <mappers>
							<mapper resource="org/mybatis/example/BlogMapper.xml"/>
						  </mappers>
					</configuration>
		
		
		从SqlSessionFactory中获取SqlSession
			SqlSession完全包含了面向数据库执行SQL命令所需的所有方法。你可以通过SqlSession实例来直接执行已映射的SQL语句。例如：
			
				SqlSession session = sqlSessionFactory.openSession();
				try {
				  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);
				} finally {
				  session.close();
				}
			
			
				SqlSession session = sqlSessionFactory.openSession();
				try {
				  BlogMapper mapper = session.getMapper(BlogMapper.class);
				  Blog blog = mapper.selectBlog(101);
				} finally {
				  session.close();
				}
		
		
		探究已映射的SQL语句
			事实上Mybatis提供的全部特性可以利用基于XML的映射语言来实现，这使得Mybatis在过去的数年间得已流行。现在给一个满足上例中的调用的例子
			eg：
				
	
				<?xml version="1.0" encoding="UTF-8" ?>
				<!DOCTYPE mapper
				  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
				  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
				<mapper namespace="org.mybatis.example.BlogMapper">
				  <select id="selectBlog" resultType="Blog">
					select * from Blog where id = #{id}
				  </select>
				</mapper>
			在一个XML映射文件中，想定义多少个映射语句都是可以的，这样下来，XML头部和文档类型占去部分就微不足道了。在命名空间
				"org.mybatis.example.BlogMapper"中定义了一个名为"selectBlog"的映射语句，这样他就允许你使用指定的完全限定名
				"org.mybatis.exapmleBlogMapper.selectBlog"来调用映射语句，就像上面的例子中做的那样。
			Blog blog = (Blog)session.selectOne("org.mybatis.example.BlogMapper.selectBlog",101);
			这个命名可以直接映射到命名空间中同名的Mapper类，并在已映射的select语句中的名字，参数和返回类型匹配成方法。
			第二种方法有很多优势，首先不是基于字符串常亮的，会更安全；其次，如果你的IDE有代码补全功能，那么可以在有了以映射SQL语句的
				基础上利用这个功能。
				
			命名空间注释：
				命名空间：之前是可选，现在是必须的，目的是希望能比只是简单的使用更长的完全限定名来更进一步区分语句。
				命名解析：为了减少输入量，MyBatis对所有的命名配置元素(包括语句，结果映射，缓存等)使用了如下的命名解析规则。
						完全限定名("som.mypackage.MyMapper.selectAllThings")：将被直接查找并且找到即用。
						短名称("selectAllThings")如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称(比如不同包下的
						selectAllThings)那么使用时会报错。这种情况必须使用完全限定名。
			映射的语句也可以不需要用XML来做，取而代用JAVA注解。
				package org.mybatis.example;
				public interface BlogMapper {
				  @Select("SELECT * FROM blog WHERE id = #{id}")
				  Blog selectBlog(int id);
				}
				
		
		作用域(Scope)和生命周期：错误的使用会导致非常严重的并发问题。
			对象生命周期和依赖注入框架。
				依赖注入框架可以创建线程安全的，基于事务的SqlSession和映射器(mapper)并将它们直接注入到你的bean中，因此可以直接忽略它们的生命
				周期。如果对如何通过依赖注入框架来使用Mybatis感兴趣的可以研究一下Mybatis-Spring或MyBatis-Guice两个子项目。
			SqlSessionFactoryBuilder		
				这个类可以被实例化，使用和丢弃，一旦创建了SqlSessionFactory,就不需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法
				作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在
				以保证所有的XML解析资源开放给更重要的事情。
			SqlSessionFactory
				SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用
				运行期间不要重复创建多次，多次创建SqlSessionFactory被视为一种代码的"坏味道"。因此SqlSessionFactory的最佳作用域是应用作用域。使用
				单例模式或者静态单例模式。
			SqlSession 
				每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域
				。绝对不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，
				要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它
				这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭：
					SqlSession session = sqlSessionFactory.openSession();
					try{
						//do work
					}finally{
						session.close()
					}	
				在你所有代码中一致性地使用这种模式来保证所有数据库资源都能被正确的关闭。
		
		映射器实例
			映射器是创建用来绑定映射语句的接口。映射器接口的实例是从SqlSession中获得的。因此从技术层面讲，映射器实例的最大作用域和SqlSession相同的，
				因为他们都是从SqlSession里被请求的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用他们的方法中被请求，
				用过之后即可废弃。并不需要显示的关闭映射器实例，尽管在整个请求作用域(request scope)保持映射器实例也不会有什么问题，但是你很快会发现，
				像SqlSession一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域内。
				SqlSession session = sqlSessionFactory.openSession();
				try{
					BlogMapper mapper = session.getMapper(BlogMapper.class);
					//do work
				}finally{
					session.close();
				}	
		
		
		
		
		
		
			